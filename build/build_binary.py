import os
import sys
import subprocess
import shutil
import datetime # For dynamic year in copyright

# --- Configuration for Icon and Version Info ---
# Path to your icon file (e.g., .ico for Windows, .icns for macOS)
# Make sure this path is correct relative to where you run the script.
ICON_PATH = os.path.abspath('../src/resources/static/img/app.ico') # <--- UPDATED: Icon path changed to src/icons/app.ico

# Path for the version resource file. This will be auto-generated if it doesn't exist.
# Changed extension to .py as it will now be a Python script.
VERSION_FILE = 'version.py' # <--- UPDATED: Version file path changed to version.py only

# Attempt to import APP_NAME and APP_VERSION from your const file
try:

    # Get the directory of the current script (my_app.py)
    current_script_dir = os.path.dirname(os.path.abspath(__file__))

    # Go up one level from 'build/' to 'my_project/'
    project_root_dir = os.path.join(current_script_dir, os.pardir)

    # Add the project root to sys.path
    if project_root_dir not in sys.path:
        sys.path.insert(0, project_root_dir) # Use insert(0, ...) to prioritize

    from src.config.const import APP_NAME, APP_VERSION

except ImportError:
    # Fallback if const.py or APP_VERSION is not found, or if APP_VERSION is missing
    APP_NAME = "Application"
    APP_VERSION = "0.0.1" # Default version if not found
    print(f"Warning: Could not import APP_NAME or APP_VERSION from src/app/config/const.py.")
    print(f"Using default APP_NAME='{APP_NAME}' and APP_VERSION='{APP_VERSION}'.")

APP_FILE = '../main.py'
DIST_DIR = '../dist/output/'
BUILD_DIR = '../dist/build/' # PyInstaller creates 'build' by default, not '_build'
EXE_NAME = APP_NAME


def generate_py_version_file_content(app_name, app_version):
    """
    Generates the content for a Python-style version.py file
    for PyInstaller's --version-file option.
    """
    current_year = datetime.datetime.now().year
    # Split version string into parts (e.g., "1.2.3" -> 1, 2, 3)
    version_parts = [int(p) for p in app_version.split('.')]
    # Ensure there are at least 4 parts for filevers and prodvers tuples
    # Pad with '0' if fewer than 4 parts
    padded_version_tuple = tuple((version_parts + [0, 0, 0, 0])[:4])

    py_content = f"""\
# UTF-8
# This file is auto-generated by the build script. Do not modify manually.
# For more details, refer to PyInstaller documentation on version resources.

VSVersionInfo(
    ffi=FixedFileInfo(
        filevers={padded_version_tuple},
        prodvers={padded_version_tuple},
        mask=0x3f,
        flags=0x0,
        OS=0x4,
        fileType=0x1,
        subtype=0x0,
        date=(0, 0)
    ),
    kids=[
        StringFileInfo(
            [
                StringTable(
                    u'040904B0', # LangID and CharSetID (e.g., US English, Unicode)
                    [
                        StringStruct(u'CompanyName', u'YKywz'),
                        StringStruct(u'FileDescription', u'{app_name}'),
                        StringStruct(u'InternalName', u'{app_name}'),
                        StringStruct(u'LegalCopyright', u'Copyright {current_year} Ykywz'),
                        StringStruct(u'ProductName', u'{app_name}'),
                        StringStruct(u'ApplicationName', u'{app_name}.exe')
                    ]
                )
            ]
        ),
        VarFileInfo([VarStruct(u'Translation', [1033, 1200])]) # US English, Unicode
    ]
)
"""
    return py_content

PYINSTALLER_CMD = [
    'pyinstaller',
    '--clean',
    '--noconfirm',
    '--console',
    '--onedir',
    # '--onefile',
    f'--workpath={BUILD_DIR}',
    f'--distpath={DIST_DIR}',
    '--add-data', '../src/resources;resources',
    '--name', EXE_NAME.replace(' ', '_'),
]

# Add icon if path is provided and exists
if os.path.exists(ICON_PATH):
    PYINSTALLER_CMD.extend(['--icon', ICON_PATH])
else:
    print(f"Warning: Icon file not found at '{ICON_PATH}'. Skipping icon inclusion.")

# --- Auto-generate or use existing version file ---
print(f"Auto-generating a basic version file...")
os.makedirs(os.path.dirname(VERSION_FILE) or '.', exist_ok=True) # Added '.' for current directory if path is just a filename
py_content = generate_py_version_file_content(APP_NAME, APP_VERSION)
try:
    # Explicitly open with utf-8 encoding to prevent UnicodeDecodeError
    with open(VERSION_FILE, 'w', encoding='utf-8') as f:
        f.write(py_content)
    print(f"Successfully generated '{VERSION_FILE}' with version {APP_VERSION}.")
except IOError as e:
    print(f"Error: Could not write to '{VERSION_FILE}': {e}")
    print("Skipping version info inclusion due to write error.")

# Add the version file to the PyInstaller command
PYINSTALLER_CMD.extend(['--version-file', VERSION_FILE])


PYINSTALLER_CMD.append(APP_FILE) # Add the main application file at the end

# print(PYINSTALLER_CMD)
# exit()

if __name__ == '__main__':
    print('--- Cleaning previous builds ---')
    if os.path.exists(DIST_DIR):
        print(f"Removing '{DIST_DIR}' directory...")
        shutil.rmtree(DIST_DIR)
    if os.path.exists(BUILD_DIR):
        print(f"Removing '{BUILD_DIR}' directory...")
        shutil.rmtree(BUILD_DIR)
    if os.path.exists(f'{EXE_NAME}.spec'):
        print(f"Removing '{EXE_NAME}.spec' file...")
        os.remove(f'{EXE_NAME}.spec')
    print('Clean-up complete.\n')

    print('--- Building executable with PyInstaller ---')
    print(f"PyInstaller command: {' '.join(PYINSTALLER_CMD)}\n")

    result = subprocess.run(PYINSTALLER_CMD, check=False) # check=False to handle non-zero exit codes

    print('\n--- Build Summary ---')
    if result.returncode == 0:
        print(f'✅ Build complete! The executable is located in the `{DIST_DIR}` directory.')
        if sys.platform.startswith('win'):
             print(f'   To run: Navigate to `{DIST_DIR}\\{EXE_NAME}` and execute `{EXE_NAME}.exe`')
        else:
             print(f'   To run: Navigate to `{DIST_DIR}/{EXE_NAME}` and execute `./{EXE_NAME}`')
    else:
        print('❌ Build failed. Please review the output above for error details.')